// JavaScript Document
var _g = globals = {};
var gen = gen || {};  //Évite d'overwritter des plugins s'il y en a

gen = function(defaultApp, root, defaultAd) {
  var self = this;
  self.path = { // Path permettant d'accèder aux divers fichiers externes utilisés.
    root:       root,
    data:       root + "data/",
    settings:   root + "data/settings/",
    images:     root + 'public/images/',
    libs:       root + "app/libraries/",
    templates:  root + 'app/templates/',
    temps:      root + 'temps/'
  };

  self.app = {
    templates: {
      options: {
        partials: {}
      },
      icons: {},
      previews: {}
    },
    idPer: {},
    dragover: false,
    keyPressed: {
      ctrl: false
    },
    settings: {}
  };
  $.extend(self.app, defaultApp);

  self.ad = {
    elems: []
  };
  $.extend(self.ad, defaultAd);

  self.props = {
    int: ["top", "left", "width", "height", "fontSize", "padding"] 
  };

  $.when( // Télécharge tous les json externes nécessaires
    $.getJSON( self.path.data + self.app.culture + "/text.json", function(r) { self.text = r; } ),
    $.get( self.path.templates + "interactivities/basic.mustache", function(r) { self.app.templates.basic = r; } ),
    $.get( self.path.templates + "interactivities/partials/gallery-pager.mustache", function(r) { self.app.templates.galleryPager = r; } ),
    $.get( self.path.templates + "interactivities/partials/gallery-pager-transparent.mustache", function(r) { self.app.templates.galleryPagerTransparent = r; } ),
    $.get( self.path.templates + "previews/gallery-pager.mustache", function(r) { self.app.templates.previews.galleryPager = r; } ),
    $.get( self.path.templates + "partials/layer.mustache", function(r) { self.app.templates.layer = r; } ),
    $.get( self.path.templates + "partials/erase.mustache", function(r) { self.app.templates.erase = r; } ),
    $.get( self.path.templates + "/options/partials/position.mustache", function(r) { self.app.templates.options.partials.position = r; } ),
    $.get( self.path.templates + "/options/partials/dimensions.mustache", function(r) { self.app.templates.options.partials.dimensions = r; } ),
    $.get( self.path.templates + "/options/partials/url.mustache", function(r) { self.app.templates.options.partials.url = r; } ),
    $.get( self.path.templates + "/options/partials/theme.mustache", function(r) { self.app.templates.options.partials.theme = r; } ),
    $.get( self.path.templates + "/icons/link.mustache", function(r) { self.app.templates.icons.link = r; } )
  ).then(function() { // Ensuite initialise la page
    //--- functions -----------------
    self.map_();
    self.init_();
    self.bindEvents_();
  });
};

//=== MAP START =====================================================
gen.prototype.map_ = function() {
  var self = this;
  self.dom = {
    b: $('body'),
    form: $('.form'),
    adContent: $('.ad-window__content'),
    elemOptions: $('.elem-options'),
    interactivitiesToolbar: $('.interactivities-toolbar'),
    layers: $('.layers__list'),
    lock: $('.js-lock-elem'),
    askErase: $('.js-askErase'),
    opacity: $('.js-opacity-elem'),
    colors: $('.colors'),
    colorsFlip: $('.js-colors-flip')
  };
};

//=== INIT START =====================================================
gen.prototype.init_ = function() {
  var self = this;

  self.detectOs_();
  self.detectBrowser_();
  self.isAdblockActive_();
  self.initInteractivitiesRelated_();
  self.initLayersSortable_();
  self.initDragElemOptions_();
  self.initColorInput_();
};

gen.prototype.closePopup_ = function( popup ) {
  var self = this;
  popup.remove();
};

/*=== Update Elem Setting ==========================================*/
gen.prototype.updateElemSetting_ = function( input ) {
  var self = this;
  var options = input.closest('.options');
  var prop = input.data('prop');
  var obj = self.getObjById_( options.data('id') );

  obj.settings[prop] = input.val();
};

/*=== Detect Drag over App ==========================================*/
gen.prototype.initDragElemOptions_ = function() {
  var self = this;
  self.dom.elemOptions.draggable({
    containment: "parent",
    handle: ".elem-options__handle"
  });
};

/*=== Detect Drag over App ==========================================*/
gen.prototype.detectDragOver_ = function( e ) {
  var self = this;
  if(e) {
    self.app.dragover = true;
    self.dom.b.addClass('dragover');
  } else {
    self.app.dragover = false;
    self.dom.b.removeClass('dragover');
  }
};

/*=== Init Interactivity Related ==========================================*/
gen.prototype.initInteractivitiesRelated_ = function() {
  var self = this;

  for(var x=0; x<self.app.settings.interactivities.length; x++) {
    var interactivity = self.app.settings.interactivities[x];

    self.getInteractivityTemplate_( interactivity );
    self.getInteractivityOptionsTemplate_( interactivity );
    self.getInteractivitySettings_( interactivity );
    self.initIdPerInteractivity_( interactivity );
  }
};

/*=== Get Interactivity Template ==========================================*/
gen.prototype.getInteractivityTemplate_ = function( interactivity ) {
  var self = this;
    $.get( self.path.templates + "interactivities/" + interactivity + ".mustache")
    .done(function(r) { 
      self.app.templates[ interactivity ] = r; 
    })
    .error(function(r) {});  
};

/*=== Get Interactivity Options Template ====================================*/
gen.prototype.getInteractivityOptionsTemplate_ = function( interactivity ) {
  var self = this;
  $.get( self.path.templates + "options/" + interactivity + ".mustache" )
  .done(function(r) { 
    self.app.templates.options[ interactivity ] = r; 
    if( interactivity === 'gallery' ) {
      $.get( self.path.templates + "options/" + interactivity + "-pager.mustache" )
      .done(function(r) { 
        self.app.templates.options[ interactivity + '-pager' ] = r; 
      })
      .error(function(r) {}); 
    }
  })
  .error(function(r) {}); 
};

/*=== Get Interactivity Settings ==========================================*/
gen.prototype.getInteractivitySettings_ = function( interactivity ) {
  var self = this;
  $.getJSON( self.path.settings + interactivity + ".json")
  .done(function(r) { 
    self.app.settings[ interactivity ] = r; 
    if( interactivity === 'gallery' ) {
      $.getJSON( self.path.settings + interactivity + "-pager.json")
      .done(function(r) { 
        self.app.settings[ interactivity + '-pager' ] = r; 
      })
      .error(function(r) {}); 
    }
  })
  .error(function(r) {}); 
};

/*=== Init Id Per Interactivity ==========================================*/
gen.prototype.initIdPerInteractivity_ = function( interactivity ) {
  var self = this;
  self.app.idPer[ interactivity ] = 0;
};

/*=== Is Adblock Active ==========================================*/
gen.prototype.isAdblockActive_ = function() {
  var self = this;
  self.app.adblock = window.canRunAds === undefined ? true : false;
};

/*=== Detect Os ==========================================*/
gen.prototype.detectOs_ = function() {
  var self = this;
  self.app.os = detectOs();
};

/*=== Detect Browser ==========================================*/
gen.prototype.detectBrowser_ = function() {
  var self = this;
  self.app.browser = detectBrowser()[0];
};

/*=== Create Elem By Type ==========================================*/
gen.prototype.createElemByType_ = function( btn ) {
  var self = this;
  var type = btn.data('type');
  var name = self.text[ type ] + " " + self.app.idPer[type];
  var elemText = typeof self.text.cta[ type ] !== 'undefined' ? self.text.cta[ type ] : name; 
  var obj = {
    meta: {
      type: type,
      id: "ad-" + type + "-" + self.app.idPer[type],
      name: name
    },
    text: {
      elem: elemText
    }
  }

  self.createElem_( obj );
};

/*=== Create Elem ==========================================*/
gen.prototype.createElem_ = function( presets, options ) {
  var self = this;
  var settings = {
    insert: "append"
  };
  if(options) {
    $.extend(settings, options);
  };
  var obj = self.createElemObj_( presets, settings );

  self.setElemHtml_( obj, settings );
  self.setLayerHtml_( obj );
  self.setOptionsHtml_( obj );
  self.setFocus_( obj );

  var functionName = 'create' + capitaliseFirstLetter( obj.meta.type ) + '_';
  if( typeof self[ functionName ] === 'function') {
    self[ functionName ]( obj );
  } 
};

/*=== Create Elem Obj ==========================================*/
gen.prototype.createElemObj_ = function( presets, settings ) {
  var self = this;
  var obj = {
    meta: {
      type: null,
      id: null,
      parent: null,
    },
    visibility: 'visible',
    locked: false,
    text: {
      elem: self.text.element,
      layer: self.text.layer,
    },
    style: {
      top:  0,
      left: 0,
      opacity: 1
    },
    override: {
      style: {}
    },
    settings: {},
    dom: {},
    elems: []
  };

  if(presets) {
    $.extend( true, obj, presets );
  }
  if(obj.meta.type !== null) {
    $.extend( true, obj, self.app.settings[ obj.meta.type ] );
  }

  $.extend( true, obj, obj.initial );

  var parent = self.ad;
  if( obj.meta.parent !== null ) {
    parent = self.getObjById_( obj.meta.parent );
  }

  if( settings.insert === "append" ) {
    parent.elems.push( obj );
  } else {
    parent.elems.unshift( obj );
  }

  self.updateIdPerInteractivity_( obj.meta.type );

  if( settings.callback ) {
    self[settings.callback]( obj );
  }

  return obj;
};

/*=== Update Id Per Interactivity ==========================================*/
gen.prototype.updateIdPerInteractivity_ = function( interactivity ) {
  var self = this;
  self.app.idPer[ interactivity ] = self.app.idPer[ interactivity ] + 1;
};

/*=== Set Elem HTML ==========================================*/
gen.prototype.setElemHtml_ = function( obj, settings ) {
  var self = this;
  var template = Mustache.render( self.app.templates.basic, obj );
  var html = $(template).append( self.app.templates[ obj.meta.type ] );
  var parent = self.dom.adContent;
  if( obj.meta.parent !== null ) {
    parent = self.getObjById_( obj.meta.parent );
    parent = parent.dom.elem;
  }
  if( settings.insert === "append" ) {
    parent.append( html );
  } else {
    parent.prepend( html );
  }
  
  obj.dom.elem = parent.find('[data-id="' + obj.meta.id + '"]');

  self.initAdElemDrag_( obj );
};

/*=== Init Elem Drag ==========================================*/
gen.prototype.initAdElemDrag_ = function( obj ) {
  var self = this;
  obj.dom.elem.draggable({
    start: function() {
      self.setFocus_( obj );
    },
    drag: function() {
      self.updateObjStyle_( obj, {
        'top':  $(this).position().top,
        'left': $(this).position().left
      });
      self.setOptionsInputValue_( 'top' );
      self.setOptionsInputValue_( 'left' );
    },
    stop: function() {
      self.updateStyle_( obj, {
        top:  $(this).position().top,
        left: $(this).position().left
      })
      self.setFocus_( obj );
    }
  });
};

/*=== Set Options HTML ==========================================*/
gen.prototype.setOptionsHtml_ = function( obj ) {
  var self = this;
  var construct = {
    elem: obj,
    text: self.text
  };

  var html = Mustache.render( self.app.templates.options[ obj.meta.type ], construct, {
    theme: self.app.templates.options.partials.theme,
    url: self.app.templates.options.partials.url,
    align: self.app.templates.options.partials.align,
    position: self.app.templates.options.partials.position,
    dimensions: self.app.templates.options.partials.dimensions
  });

  self.dom.elemOptions.append( html );
  self.dom.options = self.dom.elemOptions.find('[data-id="' + obj.meta.id + '"]');
};

/*=== Verify if Parent Can Receive Children ======================================*/
gen.prototype.verifyIfParentCanReceiveChildren_ = function( item, parent ) {
  var self = this;

  if(parent) {
    var type = self.app.focusedObj.meta.type;
    var accept = null;
    if(typeof parent.data( 'accept' ) !== 'undefined') {
      accept = parent.data( 'accept' );
    }

    if( type && accept && accept.indexOf( type ) !== -1 ) {
      parent.removeClass('no-children');
      return true;
    } else {
      parent.addClass('no-children');
      return false;
    }
  } else {
    return true;
  }
};

/*=== Update Position According To Parent ======================================*/
gen.prototype.updatePositionAccordingToParent_ = function( obj ) {
  var self = this;
  var parentPosition = {
    top:  0,
    left: 0
  };

  var parent = self.getObjById_( obj.meta.parent );
  if(parent) {
    parentPosition = {
      top:  parent.style.top,
      left: parent.style.left
    };
  }

  var position = {
    top:  self.getElemAbsolutePosition_( obj ).top - parentPosition.top,
    left: self.getElemAbsolutePosition_( obj ).left - parentPosition.left
  };

  self.updateStyle_(obj, {
    top:  position.top,
    left: position.left
  });
};

/*=== Get Elem Absolute Position ==========================================*/
gen.prototype.getElemAbsolutePosition_ = function( obj ) {
  var self = this;
  var position = {
    top:  obj.dom.elem.offset().top - self.dom.adContent.offset().top,
    left: obj.dom.elem.offset().left - self.dom.adContent.offset().left
  };
  return position;
};

/*=== Toggle Visibility =====================================*/
gen.prototype.toggleVisibility_ = function( elem ) {
  var self = this;
  var id = elem.data('id');
  var obj = self.getObjById_( id );

  if(obj.visibility === "visible") {
    obj.visibility = 'hidden';
    obj.dom.layer.addClass('layer--invisible');
    obj.dom.elem.css('display', 'none');
  } else {
    obj.visibility = 'visible';
    obj.dom.layer.removeClass('layer--invisible');
    obj.dom.elem.css('display', 'block');
  }
};

/*=== Set Focus =====================================*/
gen.prototype.setFocus_ = function( obj ) {
  var self = this;

  //console.log("%cFocus: " + obj.meta.id, "background: yellow;")
  self.dom.adContent.find('.focus').removeClass('focus');
  self.dom.layers.find('.focus').removeClass('focus');
  self.dom.elemOptions.find('.focus').removeClass('focus');

  if( obj ) {
    self.app.focusedObj = obj;
    obj.dom.elem.addClass('focus');
    obj.dom.layer = $('.layer[data-id="'+ obj.meta.id +'"]');
    obj.dom.layer.addClass('focus');
    obj.dom.options = $('.options[data-id="'+ obj.meta.id +'"]');
    obj.dom.options.addClass('focus');
  } else {
    self.app.focusedObj = null;
  }

  self.updateEraseIcon_();
  self.updateLockIcon_();
  self.updateOpacityValue_();
};

/*=== Get Obj By Id =============================*/
gen.prototype.getObjById_ = function( id, array ) {
  var self = this;
  if(!array) array = self.ad.elems;

  for(var x=0; x<array.length; x++ ) {
    if( typeof( array[x] ) === 'object' ) {
      if( array[x].meta.id === id ) {
        return array[x];
      } 
    
      var found = self.getObjById_( id, array[x].elems );
      if (found) return found;
    }  
  }
};

/*=== Remove Obj by Id From Array =============================*/
gen.prototype.removeObjByIdFromArray_ = function( id, array ) {
  var self = this;
  if(!array) array = self.ad.elems;

  for(var x=0; x<array.length; x++ ) {
    if( typeof( array[x] ) === 'object' ) {
      if( array[x].meta.id === id ) {
        array.splice(x,1);
        return false;
      }

      var found = self.removeObjByIdFromArray_( id, array[x].elems );
      if (found) return found;
    } 
  }
};

/*=== Update Style According to Options Input =========================*/
gen.prototype.updateStyleAccordingToOptionsInput_ = function( input ) {
  var self = this;
  var options = input.closest('.options');
  var prop = input.data('prop');
  var value = self.normalizeValueForObj_( prop, input.val() );
  var obj = self.getObjById_( options.data('id') ); 
  var linked = input.data('linked');
  var callback = input.data('callback');
  var style = {};


  style[prop] = value;
  if(linked) {
    style[linked] = self.value;
  }
  self.updateStyle_( obj, style);

  if(callback) {
    self[callback]( obj );
  }
};

/*=== Update Prop =============================*/
gen.prototype.updateStyle_ = function( obj, style ) {
  var self = this;
  /* Garder ligne/commentaire si dessous pour débugage */
  //console.table( [$.extend( {}, {'objet': obj.meta.name}, style)] );

  self.updateObjStyle_(obj, style);
  for(var property in style) {
    var cssValue = self.normalizeValueForCss_( property, style[property] );
    obj.dom.elem.css( property, cssValue );
    self.setOptionsInputValue_( property, obj );

    if(property === 'backgroundImage') {
      self.updateLayerPreview_( obj );
    }
  }
};

/*=== Update Obj Style =============================*/
gen.prototype.updateObjStyle_ = function( obj, style ) {
  var self = this;
  if( obj && style) {
    $.extend( obj.style, style);
  }
};

/*=== Normalize Value For Css ==========================================*/
gen.prototype.normalizeValueForObj_ = function( prop, value ) {
  var self = this;

  if( $.inArray( prop, self.props.int ) !== -1 ) {
    value = parseInt( value );
  }
  return value;
};

/*=== Normalize Value For Css ==========================================*/
gen.prototype.normalizeValueForCss_ = function( prop, value ) {
  var self = this;

  if( $.inArray( prop, self.props.int ) !== -1 ) {
    value = value + "px";
  } else if(prop === "backgroundImage") {
    value = 'url(' + value + ')';
  }
  return value;
};

/*=== Set Options Input Value ==========================================*/
gen.prototype.setOptionsInputValue_ = function( prop, obj ) {
  var self = this;
  obj = typeof obj !== 'undefined' ? obj : self.app.focusedObj;

  if( obj.dom.options ) {
    var input = obj.dom.options.find( '[data-prop="' + prop + '"]' );
    if(input) {
      input.val( obj.style[prop] );
    }
  }
};

gen.prototype.updateReadonly_ = function( props, obj ) {
  var self = this;
  var obj = obj ? obj : self.app.focusedObj;

  $.extend( obj.readonly, props);

  for(var property in props) {
    var input = obj.dom.options.find('.row.' + property);
    if(input) {
      if(props[ property ] === true) {
        input.addClass('disabled');
      } else {
        input.removeClass('disabled');
      }
    }
  }
};

gen.prototype.updateLayerName_ = function( obj, filename ) {
  var self = this;
  obj.dom.layer.find('.layer__name').text( obj.meta.name );
};














//=== BIND START =====================================================
gen.prototype.bindEvents_ = function() {
  var self = this;

  $(document).on('keydown', function(e) {
    self.updateKeyPressed_( e );
  });

  $(document).on('keyup', function() {
    self.updateKeyPressed_();
  });

  $(document).on('dragover', function() {
    clearTimeout(window.timer);
    self.detectDragOver_( true );
  });

  $(document).on('dragleave drop', function() {
    window.timer = setTimeout(function() {
      self.detectDragOver_( false );
    }, 200);
  });

  self.dom.form.on('keypress', function(e) {
    self.verifyEnter_( e );
  });

  self.dom.interactivitiesToolbar.on('click', '.js-create-ad-elem', function() {
    self.createElemByType_( $(this) );
  });

  self.dom.layers.on('click', '.js-toggle-layer-visibility', function() {
    self.toggleVisibility_( $(this).closest('.layer') );
  });

  self.dom.layers.on('click', function() {
    self.setFocus_();
  });

  self.dom.layers.on('click', '.layer', function(e) {
    e.stopImmediatePropagation();
    self.updateLayerFocus_( $(this) );
  });

  self.dom.lock.on('click', function(e) {
    e.stopImmediatePropagation();
    self.toggleLockElem_();
  });

  self.dom.opacity.on('change', function() {
    self.updateElemOpacity_();
  });

  self.dom.askErase.on('click', function() {
    self.askErase_();
  });

  self.dom.form.on('click', '.js-erase', function() {
    self.erase_();
  });

  self.dom.colorsFlip.on('click', function() {
    self.colorsFlip_();
  });

  self.dom.form.on('click', '.js-close-popup', function() {
    self.closePopup_( $(this).closest('.popup') );
  });

  self.dom.adContent.on('change', '.js-dropzone', function() {
    self.getImgFormInput_( $(this) );
  });

  self.dom.elemOptions.on('click', '.js-change-theme', function() {
    self.updateThemeIcon_( $(this) );
  });

  self.dom.elemOptions.on('change', '.js-update-elem-style', function() {
    self.updateStyleAccordingToOptionsInput_( $(this) );
  });

  self.dom.elemOptions.on('change', '.js-update-elem-setting', function() {
    self.updateElemSetting_( $(this) );
  });

  self.dom.elemOptions.on('change', '.js-update-obj-url', function() {
    self.updateObjUrl_( $(this) );
  });

  self.dom.elemOptions.on('click', '.js-align-elem', function() {
    self.alignElem_( $(this).data('position') );
  });
};
/*=== Update Key Pressed =============================*/
gen.prototype.updateKeyPressed_ = function( e ) {
  var self = this;

  if(e) {
    if(e.which === 17) { // ctrl
      self.app.keyPressed.ctrl = true;
      console.log('ctrl');
    }

    if(e.target.nodeName !== 'INPUT' || e.target.nodeName !== 'TEXTAREA') {
      if(e.which === 88) { // x
        self.colorsFlip_();
      }
    }
  } else {
    self.app.keyPressed.ctrl = false;
  }
};

/*=== Verify Enter ==========================================*/
gen.prototype.verifyEnter_ = function( e ) {
  var self = this;
  if(e.keyCode == 13) {
    e.preventDefault();
    $(':focus').blur();
  }
};
/*=== Init Layer Sortable ==========================================*/
gen.prototype.initLayersSortable_ = function() {
  var self = this;
  self.dom.layers.nestedSortable({
    items: 'li:not(.pin)',
    toleranceElement: '> div',
    opacity: 0.5,
    revert: 0,
    tolerance: 'pointer',
    placeholder: 'layer__placeholder',
    doNotClear: true,
    stop: function(event, ui) {
      var id = ui.item.data( 'id' );
      var obj = self.getObjById_( id );

      self.setFocus_( obj );
      self.updateLayer_( obj );
      self.updateLayersZindex_( self.dom.layers );
    },
    isAllowed: function(item, parent) {
      return self.verifyIfParentCanReceiveChildren_( item, parent );
    }
  });
};

gen.prototype.updateLayer_ = function( obj ) {
  var self = this;
  var obj = obj ? obj : self.app.focusedObj;
  var parentId = obj.dom.layer.parent().closest( 'li' ).data( 'id' );
  var parent = null;
  if( parentId ) {
  	parent = self.getObjById_( parentId );
  }

  if(parent === null) { // À la racine
  	if(obj.meta.parent !== parent) { // Était dans un élément et reviens à la racine
  		parent = self.getObjById_( obj.meta.parent );
  		var previousParent = parent;

  		var functionExitParent = 'update' + capitaliseFirstLetter( previousParent.meta.type ) + 'ChildrenWhenLeaving_';
        if( typeof self[ functionExitParent ] === 'function') {
          self[ functionExitParent ]( obj );
        }

  		obj.meta.parent = null;
  		self.updateLayerParent_( obj, null );

  		var updateParent = 'update' + capitaliseFirstLetter( previousParent.meta.type ) + '_';
  		console.log(updateParent, previousParent);
        if( typeof self[ updateParent ] === 'function') {
          self[ updateParent ]( previousParent );
        }
  	} else { // Change de position, mais reste à la racine

  	}
  } else { // Dans un élément
  	if( obj.meta.parent !== parent.meta.id ) { // Change d'élément

  		if( obj.meta.parent !== null) {
  			var functionExitParent = 'update' + capitaliseFirstLetter( parent.meta.type ) + 'ChildrenWhenLeaving_';
        if( typeof self[ functionExitParent ] === 'function') {
          self[ functionExitParent ]( obj );
        }
  		}
  		
  		obj.meta.parent = parent.meta.id;
  		self.updateLayerParent_( obj, parent );

  		var functionEnterParent = 'update' + capitaliseFirstLetter( parent.meta.type ) + '_';
        if( typeof self[ functionEnterParent ] === 'function') {
          self[ functionEnterParent ]( parent );
        } 
	} else { // Change de position, mais reste dans le même élément
	    var functionUpdateParentChildren = 'update' + capitaliseFirstLetter( parent.meta.type ) + 'Children_';
	    console.log("Change de position, mais reste dans le même élément", functionUpdateParentChildren);
      if( typeof self[ functionUpdateParentChildren ] === 'function') {
        self[ functionUpdateParentChildren ]( parent );
      } 
    }
  }
};

gen.prototype.updateLayerParent_ = function( obj, parent ) {
	var self = this;

	self.removeObjByIdFromArray_( obj.meta.id );
	if( parent === null ) {
		parent = self.ad;
		self.dom.adContent.append( obj.dom.elem );
	} else {

		if( parent.settings.container ) {
			parent.dom.elem.find( '.' + parent.settings.container ).append( obj.dom.elem );
		} else {
			parent.dom.elem.append( obj.dom.elem );
		}
		
	}
    parent.elems.push( obj );
    self.updatePositionAccordingToParent_( obj );
};

/*=== Update Layers Z-Index =====================================*/
gen.prototype.updateLayersZindex_ = function( ol ) {
  var self = this;
  var parent = null;
  var liNbr = ol.children('li').length;

  for(var x=0; x<liNbr; x++) {
    var li = ol.children('li')[x];
    var id = $(li).data('id');
    var obj = self.getObjById_( id );

    if(x === 0) {
      if( obj.meta.parent !== null ) {
        parent = self.getObjById_( obj.meta.parent );
      }
    }

    self.updateStyle_(obj, {
      zIndex: liNbr - x
    });

    if( obj.elems.length ) {
      self.updateLayersZindex_( $(li).children('ol') );
    }
  }

  if(parent !== null) {
    var functionName = 'update' + capitaliseFirstLetter( parent.meta.type ) + 'ChildrenPosition_';
    if( typeof self[ functionName ] === 'function') {
      self[ functionName ]( parent );
    }
  }
};

/*=== Set Layer HTML ==========================================*/
gen.prototype.setLayerHtml_ = function( obj ) {
  var self = this;
  var html = Mustache.render( self.app.templates.layer, obj );
  var parent = obj.meta.parent === null ? self.dom.layers : self.getObjById_( obj.meta.parent );
  if( obj.meta.parent !== null ) {
    parent = parent.dom.layer.children('ol');
  }

  var z = 0;
  if( parent.children('li').length ) {
    var reference = parent.children('li').eq(0);
    var referenceObj = self.getObjById_( reference.data('id') );
    z = parseInt( referenceObj.style.zIndex ) + 1;
  }

  self.updateStyle_( obj, {
    zIndex: z
  });

  parent.prepend( html );

  obj.dom.layer = parent.find('[data-id="' + obj.meta.id + '"]');
  self.updateLayerPreview_( obj );
  self.dom.layers.sortable( 'refresh' );
};


/*=== Update Layer Focus =====================================*/
gen.prototype.updateLayerFocus_ = function( layer ) {
  var self = this;
  var id = layer.data( "id" );
  var obj = self.getObjById_( id );

  self.setFocus_( obj );
};

gen.prototype.updateLayerPreview_ = function( obj ) {
  var self = this;
  var preview = null;

  if( obj.settings.layer.preview ) {
    preview = self.customLayerPreview_( obj );
  } else if( obj.style.backgroundImage ) {
    preview = obj.style.backgroundImage;
  }

  obj.dom.layer.find('.layer__preview').css({
    'background-image': 'url("' + preview + '"), url("' + self.path.images + 'ad-window-tile.png")'
  });
};

gen.prototype.customLayerPreview_ = function( obj ) {
  var self = this;
  var svg = Mustache.render( self.app.templates.previews[obj.settings.layer.preview], obj.theme.colors );
  var preview = svgToBase64( svg );
  return preview;
};

gen.prototype.updateLayerDataAttr_ = function( obj ) {
  var self = this;

  for (var key in obj.data) {
    obj.dom.layer.data( key, obj.data[key] );
  }
}
gen.prototype.askErase_ = function( obj ) {
  var self = this;
  var obj = obj ? obj : self.app.focusedObj;

  var construct = {
  	text: self.text,
  	obj: obj
  }
  var html = Mustache.render( self.app.templates.erase, construct );

  self.dom.form.append( html );
};

gen.prototype.erase_ = function( obj ) {
  var self = this;
  var obj = obj ? obj : self.app.focusedObj;
  if(obj !== null) {
    if(obj.meta.parent !== null) {
      var parent = self.getObjById_( obj.meta.parent );
      var functionName = 'update' + capitaliseFirstLetter( parent.meta.type ) + '_';
    }
    
    self.removeObjByIdFromArray_( obj.meta.id, self.ad.elems );
    obj.dom.layer.remove();
    obj.dom.elem.remove();
    obj.dom.options.remove();
    self.app.focusedObj = null;
    self.setFocus_();

    if( parent && typeof self[ functionName ] === 'function' ) {
      self[ functionName ]( parent );
    }
  }

  self.dom.form.find('.ask-erase').remove();
};

gen.prototype.updateEraseIcon_ = function() {
	var self = this;

	if( self.app.focusedObj !== null ) {
		self.dom.askErase.removeClass('disabled');
	} else {
		self.dom.askErase.addClass('disabled');
	}
}
gen.prototype.updateObjUrl_ = function( input ) {
  var self = this;
  var options = input.closest('.options');
  var prop = input.data('prop');
  var obj = self.getObjById_( options.data('id') );
  var url = addHttpIfMissing( input.val() );
  obj.url = url;
  obj.meta.name = capitaliseFirstLetter( getDomainFromUrl( url ) );
  
  self.updateLayerName_( obj );
};
gen.prototype.alignElem_ = function( position, obj ) {
  var self = this;
  var obj = obj ? obj : self.app.focusedObj;
  var max = {
    top:  self.ad.format.h,
    left: self.ad.format.w
  }
  var pos = {
    top:  obj.style.top,
    left: obj.style.left
  }

  if( obj.meta.parent !== null ) {
    var parent = self.getObjById_( obj.meta.parent );
    var max = {
      top:  parent.style.height,
      left: parent.style.width
    }
  }  

  var dimensions = {
    width:  obj.dom.elem.outerWidth(),
    height: obj.dom.elem.outerHeight()
  }

  if(position === 'vertical-top') {
    pos.top = 0;
  } else if(position === 'vertical-middle') {
    pos.top = max.top / 2 - dimensions.height / 2;
  } else if(position === 'vertical-bottom') {
    pos.top = max.top - dimensions.height;
  } else if(position === 'horizontal-left') {
    pos.left = 0;
  } else if(position === 'horizontal-middle') {
    pos.left = max.left / 2 - dimensions.width / 2;
  } else if(position === 'horizontal-right') {
    pos.left = max.left - dimensions.width;
  } 

  self.updateStyle_( obj, pos );
};
/*=== Toggle Lock Elem =====================================*/
gen.prototype.toggleLockElem_ = function() {
  var self = this;

  self.app.focusedObj.locked = self.app.focusedObj.locked === false ? true : false;

  console.log( self.app.focusedObj.locked );
  self.lockHtml_( self.app.focusedObj );

  self.updateLockIcon_();
  self.setFocus_( self.app.focusedObj );
};

/*=== Lock Html =====================================*/
gen.prototype.lockHtml_ = function( obj ) {
  var self = this;

  if(obj.override.locked) {
    obj.dom.elem.addClass( 'locked' ).draggable( 'disable' );
    obj.dom.layer.addClass( 'locked-parent' );
  } else if(obj.locked) {
    obj.dom.elem.addClass( 'locked' ).draggable( 'disable' );
    obj.dom.layer.addClass( 'locked' );
  } else {
    obj.dom.elem.removeClass( 'locked' ).draggable( 'enable' );
    obj.dom.layer.removeClass( 'locked locked-parent' );
  }

  for(var x=0; x<obj.elems.length; x++) {
    obj.elems[x].override.locked = obj.locked;
    self.lockHtml_( obj.elems[x] );
  }
};

/*=== Update Lock Icon =====================================*/
gen.prototype.updateLockIcon_ = function() {
  var self = this;

  if(self.app.focusedObj === null || self.app.focusedObj.override.locked === true) {
    self.dom.lock.closest('.layers__lock').addClass('disabled');
  } else {
    self.dom.lock.closest('.layers__lock').removeClass('disabled');

    if(self.app.focusedObj.locked === true) {
      self.dom.lock.addClass('active');
    } else {
      self.dom.lock.removeClass('active');
    }
  }
};
/*=== Update Elem Opacity =====================================*/
gen.prototype.updateElemOpacity_ = function() {
  var self = this;
  var value = self.dom.opacity.val() <= 100 ? self.dom.opacity.val() : 100;
  var opacity = value / 100;

  self.dom.opacity.val( value );

  self.updateStyle_(self.app.focusedObj, {
    opacity: opacity
  })
};

/*=== Update Opacity Value =====================================*/
gen.prototype.updateOpacityValue_ = function() {
  var self = this;
  if(self.app.focusedObj === null || self.app.focusedObj.locked === true || self.app.focusedObj.override.locked === true) {
    self.dom.opacity.closest('.layers__opacity').addClass('disabled');
  } else {
    self.dom.opacity.closest('.layers__opacity').removeClass('disabled');

    var opacity = self.app.focusedObj.style.opacity * 100;
    self.dom.opacity.val( opacity );
  }
};
gen.prototype.colorsFlip_ = function() {
  var self = this;
  var input = self.dom.colors.find('.input-color');
  input.toggleClass('front back');

  self.updateColorsRelated_(); 
};

/*=== Init Color Input ==========================================*/
gen.prototype.initColorInput_ = function( interactivity ) {
  var self = this;
  $('.input-color').colpick({
    layout:'rgbhsbhex',
    color:'ffffff',
    onSubmit:function(hsb,hex,rgb,el) {
      $(el).css('background-color', '#' + hex);
      $(el).colpickHide();

      self.updateColorsRelated_();
    },
  });
};

gen.prototype.updateColorsRelated_ = function() {
  var self = this;
  if( self.app.focusedObj.theme && self.app.focusedObj.theme.colorsSensible ) {
    var colors = self.getColors_();
    self.updateTheme_({
      colors: colors
    });
    console.log( colors );
  } 
};

gen.prototype.getColors_ = function() {
  var self = this;
  var colors = {
    no0: self.dom.colors.find('.front').css('background-color'), 
    no1: self.dom.colors.find('.back').css('background-color')
  };
  return colors;
};

gen.prototype.colorsArraytoObj_ = function( arr ) {
  var self = this;
  var obj = {}

  for(var x=0; x<arr.length; x++) {
    obj['no' + x] = arr[x];
  }

  return obj;
}
/*=== Update Theme Icon ==========================================*/
gen.prototype.updateThemeIcon_ = function( newThemeSelected ) {
  var self = this;
  var themes = self.app.focusedObj.dom.options.find('.themes');
  var currentThemeSelected = themes.find('.selected');

  currentThemeSelected.removeClass('selected');
  if(newThemeSelected) {
    newThemeSelected.addClass('selected');

    var theme = self.getIconThemeData_( newThemeSelected );
    self.updateTheme_( theme );
  }
}

/*=== Get Icon Theme =============================================*/
gen.prototype.getIconThemeData_ = function( icon ) {
  var self = this;
  var theme = {
    template: null,
    colors: null,
    colorsSensible: false
  };

  if( icon.attr('data-template') ) {
    theme.template = icon.data( 'template' );
  }

  if( icon.attr('data-colorsSensible') ) {
    theme.colorsSensible = true;
  }

  if( icon.attr('data-colors') ) {
    var colorsArr = colorsStrToArray( icon.data( 'colors' ) );
    theme.colors = self.colorsArraytoObj_( colorsArr );
  } else {
    theme.colors = self.getColors_();
  }
  
  return theme;
};

/*=== Update Theme ==================================================*/
gen.prototype.updateTheme_ = function( theme, obj ) {
  var self = this;
  var obj = obj ? obj : self.app.focusedObj;

  self.updateObjTheme_( obj, theme );
  self.updateElemTheme_( obj );
};

/*=== Update Obj Theme =============================================*/
gen.prototype.updateObjTheme_ = function( obj, theme ) {
  var self = this;
  $.extend( obj.theme, theme, true );
};

/*=== Update Elem Theme  ==========================================*/
gen.prototype.updateElemTheme_ = function( obj ) {
  var self = this;
  var obj = obj ? obj : self.app.focusedObj;
  var backgroundColor = 'transparent';
  var backgroundImage = 'none';
  var functionName = 'update' + hyphensToCamelCase( capitaliseFirstLetter( obj.meta.type ) ) + 'Theme_';
  
  if( typeof self[ functionName ] === 'function' ) { // Update via function
    self[ functionName ]( obj );
  } else if( obj.theme.template && obj.theme.template !== null ) { // Update template image
    var icon = Mustache.render( self.app.templates.icons[obj.theme.template], obj.theme.colors );
    obj.dom.elem.removeClass('empty');

    self.updateStyle_(obj, {
      backgroundColor: 'transparent',
      backgroundImage: svgToBase64( icon )
    });
  } else { // Reset empty look
    obj.dom.elem.addClass('empty');

    self.updateStyle_(obj, {
      backgroundColor: obj.settings.color.rgba,
      backgroundImage: 'none'
    });
  }
};
/*=== Update Background-image on Elem =============================*/
gen.prototype.getImgFormInput_ = function( input ) {
  var self = this;
  getImgFromInput( input, function( img ) {
    self.updateObjImg_( input, img );
  });
};

/*=== Update Obj Img =============================*/
gen.prototype.updateObjImg_ = function( input, img ) {
  var self = this;
  var elem = input.closest('[data-id]');
  var obj = self.getObjById_( elem.data('id') );
  var filename = input.val().split('\\').pop();

  obj.meta.name = cleanFilename( filename );

  self.updateLayerName_( obj );

  
  $.extend( obj, obj.populate, true );
  self.updateLayerDataAttr_( obj );

  elem.removeClass('empty');

  self.updateStyle_( obj, {
    width:  img.width,
    height: img.height,
    backgroundColor: "transparent",
    backgroundImage: img.base64
  });
};
/*=== Update Gallery ==============================================*/
gen.prototype.updateGallery_ = function( obj ) {
  var self = this;

  self.updateGalleryObj_( obj )
  self.updateGalleryPager_( obj );
  self.updateGalleryDimensions_( obj );
  self.updateGalleryChildren_( obj );
};
/*=== Update Gallery Obj ==============================================*/
gen.prototype.updateGalleryObj_ = function( gallery ) {
  var self = this;

  gallery.ImagesNbr = gallery.elems.length;
  gallery.reference = gallery.elems[0];

  if( gallery.exist.pager ) {
    gallery.ImagesNbr--;
    gallery.reference = gallery.elems[1];
  }
};

/*=== Update Gallery Pager ==============================================*/
gen.prototype.updateGalleryPager_ = function( obj ) {
  var self = this;
  var gallery = obj ? obj : self.app.focusedObj;

  if( !gallery.exist.pager && gallery.ImagesNbr >= 2 ) {
    self.createGalleryPager_( gallery );
    gallery.exist.pager = true;
  }

  if( gallery.exist.pager ) {
    var pager = self.getObjById_( gallery.meta.id + '-pager', gallery.elems );
    pager.bullets = gallery.ImagesNbr;

    if( pager.bullets <= 1 ) {
      gallery.exist.pager = false;
      self.erase_( pager );
    } else {
      self.updateGalleryPagerTheme_( pager );
    }
  }
};

/*=== Update Gallery Dimensions ==============================================*/
gen.prototype.updateGalleryDimensions_ = function( gallery ) {
  var self = this;

  console.log( gallery );

  setTimeout(function() {
    self.updateStyle_(gallery, {
      width:  gallery.reference.style.width,
      height: gallery.reference.style.height
    });
  }, 0)
  
};

/*=== Update Gallery Children ==============================================*/
gen.prototype.updateGalleryChildren_ = function( gallery ) {
  var self = this;
  var skip = 0;
  if( gallery.exist.pager ) {
    skip = 1;
  }

  setTimeout(function() {
    for(var x=0; x<gallery.ImagesNbr; x++) {
      var obj = gallery.elems[x + skip];
      var order = gallery.ImagesNbr - parseInt( obj.style.zIndex );
      var left = gallery.style.width * order;

      console.log( gallery.elems[x + skip].meta.name, parseInt( obj.style.zIndex )  );

      self.updateStyle_( obj, {
        top:  0,
        left: left
      });

      if( obj.meta.type === 'image' ) {
        self.updateReadonly_( {position: true}, obj );
        obj.dom.elem.draggable( 'disable' );
      }
    }
  }, 0)
};

/*=== Create Gallery Pager ==============================================*/
gen.prototype.createGalleryPager_ = function( gallery ) {
  var self = this;

  var obj = {
    meta: {
      type: 'gallery-pager',
      id: gallery.meta.id + '-pager',
      parent: gallery.meta.id,
      name: self.text.pager
    }
  };

  self.createElem_( obj, {
    insert: "prepend",
    callback: "setGalleryPagerDefaultPosition_"
  });
};

/*=== Set Gallery Pager Default Position ==============================================*/
gen.prototype.setGalleryPagerDefaultPosition_ = function( obj ) {
  var self = this;
  setTimeout(function() {
    self.alignElem_( 'vertical-bottom', obj);
    self.alignElem_( 'horizontal-middle', obj);
  }, 0)
  
};

/*=== Update Gallery Pager Theme ==============================================*/
gen.prototype.updateGalleryPagerTheme_ = function( pager ) {
  var self = this;

  if(pager.theme.colorsSensible) {
    $.extend( pager.theme.colors, self.getColors_() );
  };

  self.updateStyle_( pager, {
    width: (pager.style.fontSize + 4) * pager.bullets,
    height: pager.style.fontSize
  });

  var constructor = {
    height: pager.style.height,
    padding: pager.style.padding,
    radius: (pager.style.height + pager.style.padding * 2) / 2,
    bullets: []
  };

  for(var x=0; x<pager.bullets; x++) {
    var bullet = {
      size: pager.style.fontSize,
      color: pager.theme.colors.no1
    }
    if(pager.selected === x) {
      bullet.color = pager.theme.colors.no0;
    }
    constructor.bullets.push( bullet );
  }

  self.updateLayerPreview_( pager );

  var html = Mustache.render( self.app.templates[pager.theme.template], constructor );
  pager.dom.elem.find('.elem__container').html( html );
};

/*=== Update Gallery Children When Leaving ==============================================*/
gen.prototype.updateGalleryChildrenWhenLeaving_ = function( obj ) {
  var self = this;

  console.log('updateGalleryChildrenWhenLeaving_', obj.meta.name);
  self.updateReadonly_( {position: false}, obj );
  obj.dom.elem.draggable( 'enable' );
};